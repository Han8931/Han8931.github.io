[{"categories":["Python"],"content":"A tutorial for Pydantic","date":"2024-04-26","objectID":"/20240426_pydantic/","tags":["Python","Pydantic"],"title":"Data validation with Pydantic!","uri":"/20240426_pydantic/"},{"categories":["Python"],"content":"Python’s dynamic typing system is indeed convenient, allowing you to create variables without explicitly declaring their types. While this flexibility can streamline development, it can also introduce unexpected behavior, particularly when handling data from external sources like APIs or user input. Consider the following scenario: employee = Employee(\"Han\", 30) # Correct employee = Employee(\"Moon\", \"30\") # Correct Here, the second argument is intended to represent an age, typically an integer. However, in the second example, it’s a string, potentially leading to errors or unexpected behavior down the line. To address such issues, Pydantic offers a solution through data validation. Pydantic is a library specifically designed for this purpose, ensuring that the data conforms to pre-defined schemas. The primary method of defining schemas in Pydantic is through models. Models are essentially classes that inherit from pydantic.BaseModel and define fields with annotated attributes. You can think of models as similar to structs in languages like C. While Pydantic models share similarities with Python’s dataclasses, they are preferred when data validation is essential. Pydantic models guarantee that the fields of an instance will adhere to specified types, providing both runtime validation and serving as type hints during development. Let’s illustrate this with a simple example: from pydantic import BaseModel class User(BaseModel): id: int name: str = \"John Doe\" User model has two fields: id integer and name string, which has a default value. You can create an instance, user = User(id=\"123\") You can also define models that include other models, allowing for complex data structures: from typing import List class Item(BaseModel): name: str price: float class Order(BaseModel): items: List[Item] total_price: float order = Order(items=[{\"name\": \"Burger\", \"price\": 5.99}, {\"name\": \"Fries\", \"price\": 2.99}], total_price=8.98) print(order) ","date":"2024-04-26","objectID":"/20240426_pydantic/:0:0","tags":["Python","Pydantic"],"title":"Data validation with Pydantic!","uri":"/20240426_pydantic/"},{"categories":["Python"],"content":"Validators Pydantic provides a versatile decorator called validator, which enables you to impose custom validation rules on model fields. These validators extend beyond simple type validation and allow you to enforce additional checks. Here’s how you can define and utilize a custom validator: from pydantic import BaseModel, validator class Person(BaseModel): name: str age: int @validator('age') def check_age(cls, value): if value \u003c 18: raise ValueError('Age must be at least 18') return value # This will raise an error because the age is below 18 try: Person(name=\"Charlie\", age=17) except Exception as e: print(e) In this example, the custom validator ensures that the age provided is at least 18 years. Custom validators can target individual fields, multiple fields, or the entire model, making them invaluable for enforcing complex validation logic or cross-field constraints. ","date":"2024-04-26","objectID":"/20240426_pydantic/:1:0","tags":["Python","Pydantic"],"title":"Data validation with Pydantic!","uri":"/20240426_pydantic/"},{"categories":["Python"],"content":"Built-in Validators Pydantic models leverage Python type annotations to enforce data types. Alongside the fundamental types like str, int, float, bool, Pydantic supports complex data types such as List, Dict, Union, and Optional, among others. These annotations are the first level of validation: from pydantic import BaseModel from typing import List, Optional class User(BaseModel): name: str age: int tags: Optional[List[str]] = None In this example, name must be a string, age an integer, and tags is an optional list of strings. ","date":"2024-04-26","objectID":"/20240426_pydantic/:1:1","tags":["Python","Pydantic"],"title":"Data validation with Pydantic!","uri":"/20240426_pydantic/"},{"categories":["Python"],"content":"Field Validation For more detailed validation, Pydantic’s Field function can be used to specify additional constraints: from pydantic import BaseModel, Field class User(BaseModel): id: int name: str email: str = Field(..., description=\"The email address of the user\") age: int = Field(..., gt=0, description=\"The age of the user\") # Usage user_data = {\"id\": 1, \"name\": \"John\", \"email\": \"john@example.com\", \"age\": 30} user = User(**user_data) In this example: id, name, email, and age represents fields in the User model. id and name are required fields because they don’t have a default value. email and age have default values specified using the Field class. For email, ... indicates that it’s required, and a description is provided. For age, ... indicates that it’s required, and it must be greater than zero (gt=0). By using Field, you can define additional constraints such as minimum and maximum values, regular expressions for string fields, custom validation functions, etc., to ensure that your data meets specific criteria. age: int = Field(..., gt=0, description=\"The age of the user\") For instance, you can specifies that the age must be greater than 0. ","date":"2024-04-26","objectID":"/20240426_pydantic/:1:2","tags":["Python","Pydantic"],"title":"Data validation with Pydantic!","uri":"/20240426_pydantic/"},{"categories":["Python"],"content":"Root Validators For validation that involves multiple fields, you can use root validators. These are applied to the whole model instead of individual fields: from pydantic import BaseModel, root_validator class Account(BaseModel): username: str password1: str password2: str @root_validator def passwords_match(cls, values): password1, password2 = values.get('password1'), values.get('password2') if password1 and password2 and password1 != password2: raise ValueError('Passwords do not match') return values Root validators have access to all field values of the model, making them ideal for validations that depend on multiple fields. ","date":"2024-04-26","objectID":"/20240426_pydantic/:1:3","tags":["Python","Pydantic"],"title":"Data validation with Pydantic!","uri":"/20240426_pydantic/"},{"categories":["Python"],"content":"Pre-Validators and Post-Validators Pre-validators: A pre-validator in Pydantic is used to preprocess or transform the data before it undergoes the main validation process. This is particularly useful when you need to adjust or prepare the incoming data so it can be successfully validated. For instance, you might want to strip whitespace from a string, convert data types, or decompose compound fields into simpler components before validation. from pydantic import BaseModel, validator class TrimmedStringModel(BaseModel): text: str @validator('text', pre=True) def strip_whitespace(cls, value): return value.strip() Post-validator Post-validators are used to validate or transform data after the main validation process. They are useful when certain validations depend on multiple fields or when you need to enforce complex constraints that are not covered by basic type annotations. Post-validators are also defined using the @validator decorator but without specifying pre=True. ","date":"2024-04-26","objectID":"/20240426_pydantic/:1:4","tags":["Python","Pydantic"],"title":"Data validation with Pydantic!","uri":"/20240426_pydantic/"},{"categories":["Python"],"content":"Json Serialization It is really simple to convert Pydantic models to or from JSON. For example, user_json = user.json() You can convert your model instance to JSON file as above. Or you can make a dictionary by user.dict() Conversely, json_str = '{\"name\": \"Han\", \"account\": 1234}' User.parse_raw(json_str) ","date":"2024-04-26","objectID":"/20240426_pydantic/:2:0","tags":["Python","Pydantic"],"title":"Data validation with Pydantic!","uri":"/20240426_pydantic/"},{"categories":["Python"],"content":"Pydantic for Config Pydantic can also be used for settings management by loading configuration from environment variables: from pydantic_settings import BaseSettings from pydantic.types import SecretStr class DatabaseSettings(BaseSettings): api_key: str database_password: str my_database_settings = DatabaseSettings(_env_file=\".env\") print(my_database_settings.api_key) This feature is particularly useful for 12-factor apps that require configuration through the environment for different deployment environments. Pydantic provides a powerful system for data validation, allowing you to enforce type constraints and custom validation rules on your data models. This capability ensures that the data your application works with is correct and consistent, reducing runtime errors and simplifying data handling. Let’s explore more about validation in Pydantic, including built-in validators and how to write custom validation functions. ","date":"2024-04-26","objectID":"/20240426_pydantic/:3:0","tags":["Python","Pydantic"],"title":"Data validation with Pydantic!","uri":"/20240426_pydantic/"},{"categories":["Python"],"content":"Pydantic SecretStr Pydantic’s SecretStr is a special data type designed to handle sensitive information, such as passwords or secret tokens, in a more secure manner. This type is part of Pydantic’s data types that provide tools for sensitive data, ensuring that such information isn’t accidentally printed or logged, which could lead to security vulnerabilities. from pydantic import BaseModel, SecretStr class User(BaseModel): username: str password: SecretStr # Usage user_data = {\"username\": \"john_doe\", \"password\": \"secretpassword\"} user = User(**user_data) print(user) # Output: User username='john_doe' password=SecretStr('********') from pydantic import BaseModel, SecretBytes class EncryptedData(BaseModel): data: SecretBytes # Usage encrypted_data = {\"data\": b\"encrypted binary data\"} data_object = EncryptedData(**encrypted_data) print(data_object) # Output: EncryptedData data=SecretBytes('********') from pydantic_settings import BaseSettings from pydantic.types import SecretStr class DatabaseSettings(BaseSettings): api_key: SecretStr database_password: SecretStr my_database_settings = DatabaseSettings(_env_file=\".env\") print(my_database_settings.api_key) ","date":"2024-04-26","objectID":"/20240426_pydantic/:3:1","tags":["Python","Pydantic"],"title":"Data validation with Pydantic!","uri":"/20240426_pydantic/"},{"categories":["Programming"],"content":"A gentle introduction to bash scripting","date":"2024-04-21","objectID":"/20240421_the-shell-script-tutorial/","tags":["Python","bash","shell script","linux"],"title":"Bash script tutorial","uri":"/20240421_the-shell-script-tutorial/"},{"categories":["Programming"],"content":"Let’s create our first simple shell script #!/bin/sh # This is a comment! echo Hello World # This is a comment, too! The first line tells Unix that the file is to be executed by /bin/sh. This is the standard location of the Bourne shell on just about every Unix system. If you’re using GNU/Linux, /bin/sh is normally a symbolic link to bash (or, more recently, dash). The second line begins with a special symbol: #. This marks the line as a comment, and it is ignored completely by the shell. The only exception is when the very first line of the file starts with #! (shebang) - as ours does. This is a special directive which Unix treats specially. It means that even if you are using csh, ksh, or anything else as your interactive shell, that what follows should be interpreted by the Bourne shell. Similarly, a Perl script may start with the line #!/usr/bin/perl to tell your interactive shell that the program which follows should be executed by perl. For Bourne shell programming, we shall stick to #!/bin/sh. The third line runs a command: echo, with two parameters, or arguments - the first is \"Hello\"; the second is \"World\". Note that echo will automatically put a single space between its parameters. To make it executable, run chmod +rx \u003cfilename\u003e ","date":"2024-04-21","objectID":"/20240421_the-shell-script-tutorial/:0:0","tags":["Python","bash","shell script","linux"],"title":"Bash script tutorial","uri":"/20240421_the-shell-script-tutorial/"},{"categories":["Programming"],"content":"Variables Let’s look back at our first Hello World example. This could be done using variables. Note that there must be no spaces around the “=” sign: VAR=value works; VAR = value doesn’t work. In the first case, the shell sees the “=” symbol and treats the command as a variable assignment. In the second case, the shell assumes that VAR must be the name of a command and tries to execute it. #!/bin/sh MY_MESSAGE=\"Hello World\" echo $MY_MESSAGE This assigns the string “Hello World” to the variable MY_MESSAGE then echoes out the value of the variable. Note that we need the quotes around the string Hello World. Whereas we could get away with echo Hello World because echo will take any number of parameters, a variable can only hold one value, so a string with spaces must be quoted so that the shell knows to treat it all as one. Otherwise, the shell will try to execute the command World after assigning MY_MESSAGE=Hello The shell does not care about types of variables; they may store strings, integers, real numbers - anything you like. We can interactively set variable names using the read command; the following script asks you for your name then greets you personally #!/bin/sh echo What is your name? read MY_NAME echo \"Hello $MY_NAME - hope you're well.\" ","date":"2024-04-21","objectID":"/20240421_the-shell-script-tutorial/:1:0","tags":["Python","bash","shell script","linux"],"title":"Bash script tutorial","uri":"/20240421_the-shell-script-tutorial/"},{"categories":["Programming"],"content":"Escape Characters Certain characters are significant to the shell; for example, that the use of double quotes (\") characters affect how spaces and TAB characters are treated, for example: $ echo Hello World Hello World $ echo \"Hello World\" Hello World So how do we display: Hello \"World\" ? $ echo \"Hello \\\"World\\\"\" The first and last \" characters wrap the whole lot into one parameter passed to echo so that the spacing between the two words is kept as is. But the code: $ echo \"Hello \" World \"\" would be interpreted as three parameters: “Hello \" World \"” So the output would be Hello World Note that we lose the quotes entirely. This is because the first and second quotes mark off the Hello and following spaces; the second argument is an unquoted “World” and the third argument is the empty string; “”. ","date":"2024-04-21","objectID":"/20240421_the-shell-script-tutorial/:2:0","tags":["Python","bash","shell script","linux"],"title":"Bash script tutorial","uri":"/20240421_the-shell-script-tutorial/"},{"categories":["Programming"],"content":"Loop ","date":"2024-04-21","objectID":"/20240421_the-shell-script-tutorial/:3:0","tags":["Python","bash","shell script","linux"],"title":"Bash script tutorial","uri":"/20240421_the-shell-script-tutorial/"},{"categories":["Programming"],"content":"For Loop #!/bin/sh for i in 1 2 3 4 5 do echo \"Looping ... number $i\" done #!/bin/sh for i in hello 1 * 2 goodbye do echo \"Looping ... i is set to $i\" done The output of the above code is Looping ... i is set to hello Looping ... i is set to 1 Looping ... i is set to (name of first file in current directory) ... etc ... Looping ... i is set to (name of last file in current directory) Looping ... i is set to 2 Looping ... i is set to goodbye This is well worth trying. Make sure that you understand what is happening here. Try it without the * and grasp the idea, then re-read the Wildcards section and try it again with the * in place. Try it also in different directories, and with the * surrounded by double quotes, and try it preceded by a backslash (\\*) ","date":"2024-04-21","objectID":"/20240421_the-shell-script-tutorial/:3:1","tags":["Python","bash","shell script","linux"],"title":"Bash script tutorial","uri":"/20240421_the-shell-script-tutorial/"},{"categories":["Programming"],"content":"While Loop #!/bin/sh INPUT_STRING=hello while [ \"$INPUT_STRING\" != \"bye\" ] do echo \"Please type something in (bye to quit)\" read INPUT_STRING echo \"You typed: $INPUT_STRING\" done #!/bin/sh while : do echo \"Please type something in (^C to quit)\" read INPUT_STRING echo \"You typed: $INPUT_STRING\" done The colon (:) always evaluates to true; whilst using this can be necessary sometimes, it is often preferable to use a real exit condition. Compare quitting the above loop with the one below; see which is the more elegant. Also think of some situations in which each one would be more useful than the other: #!/bin/sh while read input_text do case $input_text in hello) echo English ;; howdy) echo American ;; gday) echo Australian ;; bonjour) echo French ;; \"guten tag\") echo German ;; *) echo Unknown Language: $input_text ;; esac done \u003c myfile.txt This reads the file “myfile.txt”, one line at a time, into the variable “$input_text”. The case statement then checks the value of $input_text. If the word that was read from myfile.txt was “hello” then it echoes the word “English”. If it was “gday” then it will echo Australian. If the word (or words) read from a line of myfile.txt don’t match any of the provided patterns, then the catch-all “*” default will display the message “Unknown Language: $input_text” - where of course “$input_text” is the value of the line that it read in from myfile.txt. A handy Bash (but not Bourne Shell) tip I learned recently from the Linux From Scratch project is: mkdir rc{0,1,2,3,4,5,6,S}.d instead of the more cumbersome: for runlevel in 0 1 2 3 4 5 6 S do mkdir rc${runlevel}.d done And ls can be done recursively, too: $ cd / $ ls -ld {,usr,usr/local}/{bin,sbin,lib} drwxr-xr-x 2 root root 4096 Oct 26 01:00 /bin drwxr-xr-x 6 root root 4096 Jan 16 17:09 /lib drwxr-xr-x 2 root root 4096 Oct 27 00:02 /sbin drwxr-xr-x 2 root root 40960 Jan 16 19:35 usr/bin drwxr-xr-x 83 root root 49152 Jan 16 17:23 usr/lib drwxr-xr-x 2 root root 4096 Jan 16 22:22 usr/local/bin drwxr-xr-x 3 root root 4096 Jan 16 19:17 usr/local/lib drwxr-xr-x 2 root root 4096 Dec 28 00:44 usr/local/sbin drwxr-xr-x 2 root root 8192 Dec 27 02:10 usr/sbin ","date":"2024-04-21","objectID":"/20240421_the-shell-script-tutorial/:3:2","tags":["Python","bash","shell script","linux"],"title":"Bash script tutorial","uri":"/20240421_the-shell-script-tutorial/"},{"categories":["Programming"],"content":"Test Test is used by virtually every shell script written. It may not seem that way, because test is not often called directly. test is more frequently called as [. [ is a symbolic link to test, just to make shell programs more readable. It is also normally a shell builtin (which means that the shell itself will interpret [ as meaning test, even if your Unix environment is set up differently): $ type [ [ is a shell builtin $ which [ /usr/bin/[ $ ls -l /usr/bin/[ lrwxrwxrwx 1 root root 4 Mar 27 2000 /usr/bin/[ -\u003e test $ ls -l /usr/bin/test -rwxr-xr-x 1 root root 35368 Mar 27 2000 /usr/bin/test This means that ‘[’ is actually a program, just like ls and other programs, so it must be surrounded by spaces: if [$foo = \"bar\" ] will not work; it is interpreted as if test$foo = \"bar\" ], which is a ‘]’ without a beginning ‘[’. Put spaces around all your operators. I’ve highlighted the mandatory spaces with the word ‘SPACE’ . Note: Some shells also accept “==” for string comparison; this is not portable, a single “=” should be used for strings, or “-eq” for integers. Test is a simple but powerful comparison utility. For full details, run man test on your system, but here are some usages and typical examples. Test is most often invoked indirectly via the if and while statements. It is also the reason you will come into difficulties if you create a program called test and try to run it, as this shell builtin will be called instead of your program! The syntax for if...then...else... is: if [ ... ] then # if-code else # else-code fi Also, be aware of the syntax - the “if [ ... ]” and the “then” commands must be on different lines. Alternatively, the semicolon “;” can separate them: if [ ... ]; then # do something fi You can also use the elif, like this: if [ something ]; then echo \"Something\" elif [ something_else ]; then echo \"Something else\" else echo \"None of the above\" fi This will echo \"Something\" if the [ something ] test succeeds, otherwise it will test [ something_else ], and echo \"Something else\" if that succeeds. If all else fails, it will echo \"None of the above\". ","date":"2024-04-21","objectID":"/20240421_the-shell-script-tutorial/:4:0","tags":["Python","bash","shell script","linux"],"title":"Bash script tutorial","uri":"/20240421_the-shell-script-tutorial/"},{"categories":["Programming"],"content":"Case The case statsement saves going through a whole set of if ... then ... else statements. Its syntax is really simple: #!/bin/sh echo \"Please talk to me ...\" while : do read INPUT_STRING case $INPUT_STRING in hello) echo \"Hello yourself!\" ;; bye) echo \"See you again!\" break ;; *) echo \"Sorry I don't understand\" ;; esac done ","date":"2024-04-21","objectID":"/20240421_the-shell-script-tutorial/:5:0","tags":["Python","bash","shell script","linux"],"title":"Bash script tutorial","uri":"/20240421_the-shell-script-tutorial/"},{"categories":["Programming"],"content":"Variables 2 The first set of variables we will look at are $0 ... $9 and $#. The variable $0 is the basename of the program as it was called. $1...$9 are the first 9 additional parameters the script was called with. The variable $@ is all parameters. The variable $* is similar, but does not preserve any whitespace and quoting, so “File with spaces” becomes “File”, “with”, and “spaces”. $# is the number of parameters the script was called with. #!/bin/sh echo \"I was called with $# parameters\" echo \"My name is $0\" echo \"My first parameter is $1\" The othere two main variables set are $$ and $!. These are both process numbers. The $$ variable is the PID of the currently running shell. This can be useful for creating temporary files, such as /tmp/my-script.$$ which is useful if many instances of the script could be run at the same time, and they all need their own temporary files. The $! variable is the PID of the last run background processd. This is useful to keep track of the process as it gets on with its job. Another interesting vardfiable is IFS. This is the Interfal Field Separator. The default value is SPACE TAB NEWLINE, but if you are changing it, it’s easier to take a copy as shown: #!/bin/sh old_IFS=\"$IFS\" IFS=: # Set IFS as colon echo \"Please input some data separated by colons\" read x y z IFS=$old_IFS echo \"x is $x y is $y z is $z\" ","date":"2024-04-21","objectID":"/20240421_the-shell-script-tutorial/:6:0","tags":["Python","bash","shell script","linux"],"title":"Bash script tutorial","uri":"/20240421_the-shell-script-tutorial/"},{"categories":["Programming"],"content":"Functions #!/bin/sh add_a_user() { USER=$1 PASSWORD=$2 COMMENTS=$@ echo \"Adding user $USER\" echo useradd -c \"$COMMENTS\" $USER echo passwd $USER $PASSWORD } ","date":"2024-04-21","objectID":"/20240421_the-shell-script-tutorial/:7:0","tags":["Python","bash","shell script","linux"],"title":"Bash script tutorial","uri":"/20240421_the-shell-script-tutorial/"},{"categories":["Programming"],"content":"Reference shellscript ","date":"2024-04-21","objectID":"/20240421_the-shell-script-tutorial/:8:0","tags":["Python","bash","shell script","linux"],"title":"Bash script tutorial","uri":"/20240421_the-shell-script-tutorial/"},{"categories":["Linux"],"content":"You should use Linux!","date":"2024-04-21","objectID":"/20240421_why-linux/","tags":["Linux","Minimalism"],"title":"Minimalism Through Linux","uri":"/20240421_why-linux/"},{"categories":["Linux"],"content":"Linux, A Path to Digital Simplicity In an age dominated by digital clutter and overwhelming software choices, the minimalist philosophy stands out as a beacon for those seeking simplicity and efficiency. This approach not only applies to physical possessions but extends into the digital realm, where Linux has become a preferred tool for minimalists. Linux, an open-source operating system, embodies the principles of minimalism by offering users control over their digital environments. Unlike mainstream operating systems that often come loaded with non-essential features and bloatware, Linux allows users to select only the components they need, creating a lean and efficient system. The minimalist appeal of Linux is evident in its customizable nature. Users can choose from a variety of distributions, each tailored for different needs. For instance, distributions like Arch Linux provide barebone setup that users can expand as needed. This customization extends to the user interface, where options range from feature-rich desktop environments to more austere ones like i3wm or DWM, which use fewer resources and maintain a clean, unobtrusive design. Furthermore, Linux’s robust command-line interface is a minimalist’s dream. It enables users to perform tasks efficiently without the graphical overhead, which is particularly appealing to those who favor functionality and speed over visual elements. Moreover, Linux supports the concept of free software, which resonates with minimalists’ preference for authenticity and freedom from commercial constraints. Users are free to modify, improve, and redistribute their software in ways that proprietary systems do not allow. Linux offers a compelling choice for anyone looking to embrace a minimalist digital lifestyle. It provides the tools to create a personalized and simple digital environment, encourages the efficient use of resources, and upholds values of freedom and simplicity. For those seeking to reduce their digital footprint while maximizing functionality, Linux proves that less can indeed be more. ","date":"2024-04-21","objectID":"/20240421_why-linux/:0:1","tags":["Linux","Minimalism"],"title":"Minimalism Through Linux","uri":"/20240421_why-linux/"},{"categories":["Python"],"content":"Guide to keep sensitive data in Python","date":"2024-04-20","objectID":"/20240421_hide-sensitive-data/","tags":["Python","dotenv"],"title":"How to keep sensitive data in Python?","uri":"/20240421_hide-sensitive-data/"},{"categories":["Python"],"content":"An app’s config is everything that is likely to vary between deploys (staging, production, developer environments, etc). This includes: Resource handles to the database, Memcached, and other backing services Credentials to external services such as Amazon S3 or Twitter Per-deploy values such as the canonical hostname for the deploy Apps sometimes store config as constants in the code. This is a violation of twelve-factor, which requires strict separation of config from code. Config varies substantially across deploys, code does not. A litmus test for whether an app has all config correctly factored out of the code is whether the codebase could be made open source at any moment, without compromising any credentials. The twelve-factor app stores config in environment variables (often shortened to env vars or env). Env vars are easy to change between deploys without changing any code; unlike config files, there is little chance of them being checked into the code repo accidentally; and unlike custom config files, or other config mechanisms such as Java System Properties, they are a language- and OS-agnostic standard. In a twelve-factor app, env vars are granular controls, each fully orthogonal to other env vars. They are never grouped together as “environments”, but instead are independently managed for each deploy. This is a model that scales up smoothly as the app naturally expands into more deploys over its lifetime. ","date":"2024-04-20","objectID":"/20240421_hide-sensitive-data/:0:0","tags":["Python","dotenv"],"title":"How to keep sensitive data in Python?","uri":"/20240421_hide-sensitive-data/"},{"categories":["Python"],"content":"Environment Variable For example, you shouldn’t put information directly in your code. db_user = 'my_db_user' db_password = 'my_db_pass_123!' Let’s keep the sensitive information in .bash_profile as follows: export DB_USER=\"my_db_user\" export DB_PASS='my_db_pass_123!' Then, we can call them by import os db_user = os.environ.get('DB_USER') db_password = os.environ.get('DB_PASS') ","date":"2024-04-20","objectID":"/20240421_hide-sensitive-data/:1:0","tags":["Python","dotenv"],"title":"How to keep sensitive data in Python?","uri":"/20240421_hide-sensitive-data/"},{"categories":["Python"],"content":"dotenv ","date":"2024-04-20","objectID":"/20240421_hide-sensitive-data/:2:0","tags":["Python","dotenv"],"title":"How to keep sensitive data in Python?","uri":"/20240421_hide-sensitive-data/"},{"categories":["Python"],"content":"Introduction Python-dotenv reads key-value pairs from a .env file and can set them as environment variables. It helps in the development of applications following the 12-factor principles. ","date":"2024-04-20","objectID":"/20240421_hide-sensitive-data/:2:1","tags":["Python","dotenv"],"title":"How to keep sensitive data in Python?","uri":"/20240421_hide-sensitive-data/"},{"categories":["Python"],"content":"Basics Installation: pip install python-dotenv Create .env file in your project directory. Put the data (or variables) in the .env file. e.g, API_KEY=\"dafjei304aldkjf20akj\" To load your key, First, use load_dotenv() with os.getenv(\"[Your variable]\") e.g., API_KEY=os.getenv(\"API_KEY\") Make sure to update .gitignore to exclude the .env file. from dotenv import load_dotenv load_dotenv() API_KEY = os.getenv(\"API_KEY\") or \"\" ","date":"2024-04-20","objectID":"/20240421_hide-sensitive-data/:2:2","tags":["Python","dotenv"],"title":"How to keep sensitive data in Python?","uri":"/20240421_hide-sensitive-data/"},{"categories":["Python"],"content":"Reference The Twelve Factor App ","date":"2024-04-20","objectID":"/20240421_hide-sensitive-data/:3:0","tags":["Python","dotenv"],"title":"How to keep sensitive data in Python?","uri":"/20240421_hide-sensitive-data/"},{"categories":["Python"],"content":"Guide to understand type hint in Python.","date":"2024-04-20","objectID":"/20240421_type-hint/","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":["Python"],"content":"Type hinting is not mandatory, but it can make your code easier to understand and debug by Improved readability Better IDE support: IDEs and linters can use type hints to check your code for potential errors before runtime. While type hints can be simple classes like float or str , they can also be more complex. The typing module provides a vocabulary of more advanced type hints. ","date":"2024-04-20","objectID":"/20240421_type-hint/:0:0","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":["Python"],"content":"Basics # This is how you declare the type of a variable age: int = 1 # You don't need to initialize a variable to annotate it a: int # Ok (no value at runtime until assigned) # Doing so can be useful in conditional branches child: bool if age \u003c 18: child = True else: child = False x: int = 1 x: float = 1.0 x: bool = True x: str = \"test\" x: bytes = b\"test\" # For collections on Python 3.9+, the type of the collection item is in brackets x: list[int] = [1] x: set[int] = {6, 7} # For mappings, we need the types of both keys and values x: dict[str, float] = {\"field\": 2.0} # Python 3.9+ # For tuples of fixed size, we specify the types of all the elements x: tuple[int, str, float] = (3, \"yes\", 7.5) # Python 3.9+ # For tuples of variable size, we use one type and ellipsis x: tuple[int, ...] = (1, 2, 3) # Python 3.9+ # On Python 3.8 and earlier, the name of the collection type is # capitalized, and the type is imported from the 'typing' module from typing import List, Set, Dict, Tuple x: List[int] = [1] x: Set[int] = {6, 7} x: Dict[str, float] = {\"field\": 2.0} x: Tuple[int, str, float] = (3, \"yes\", 7.5) x: Tuple[int, ...] = (1, 2, 3) ","date":"2024-04-20","objectID":"/20240421_type-hint/:0:1","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":["Python"],"content":"Union Union is for multiple types def process_message(msg: Union[str, bytes, None]) -\u003e str: ... # On Python 3.10+, use the | operator when something could be one of a few types x: list[int | str] = [3, 5, \"test\", \"fun\"] # Python 3.10+ # On earlier versions, use Union x: list[Union[int, str]] = [3, 5, \"test\", \"fun\"] ","date":"2024-04-20","objectID":"/20240421_type-hint/:0:2","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":["Python"],"content":"Optional # food can be either str or None. def eat_food(food: Optional[str]) -\u003e None: ... # Use Optional[X] for a value that could be None # Optional[X] is the same as X | None or Union[X, None] x: Optional[str] = \"something\" if some_condition() else None if x is not None: # Mypy understands x won't be None here because of the if-statement print(x.upper()) # If you know a value can never be None due to some logic that mypy doesn't # understand, use an assert assert x is not None print(x.upper()) ","date":"2024-04-20","objectID":"/20240421_type-hint/:0:3","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":["Python"],"content":"Any Any is a special type hint in Python that indicates that a variable can be of any type. It essentially disables static type checking for that variable. It’s typically used when you want to explicitly indicate that a certain variable can have any type, or when dealing with dynamically typed code where the type of the variable cannot be easily inferred. While Any provides flexibility, it also sacrifices the benefits of static type checking, as type errors related to variables annotated as Any won’t be caught by type checkers. ","date":"2024-04-20","objectID":"/20240421_type-hint/:0:4","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":["Python"],"content":"Functions: Callable Types Callable type hint can define types for callable functions. from typing import Callable Callable[[Parameter types, ...], return_types] Callable objects are functions, classes, and so on. Type [input types] and return types def on_some_event_happened(callback: Callable[[int, str, str], int]) -\u003e None: ... def do_this(a: int, b: str, c:str) -\u003e int: ... on_some_event_happened(do_this) # This is how you annotate a callable (function) value x: Callable[[int, float], float] = f def register(callback: Callable[[str], int]) -\u003e None: ... # A generator function that yields ints is secretly just a function that # returns an iterator of ints, so that's how we annotate it def gen(n: int) -\u003e Iterator[int]: i = 0 while i \u003c n: yield i i += 1 # You can of course split a function annotation over multiple lines def send_email(address: Union[str, list[str]], sender: str, cc: Optional[list[str]], bcc: Optional[list[str]], subject: str = '', body: Optional[list[str]] = None ) -\u003e bool: ... ","date":"2024-04-20","objectID":"/20240421_type-hint/:0:5","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":["Python"],"content":"Classes class BankAccount: # The \"__init__\" method doesn't return anything, so it gets return # type \"None\" just like any other method that doesn't return anything def __init__(self, account_name: str, initial_balance: int = 0) -\u003e None: # mypy will infer the correct types for these instance variables # based on the types of the parameters. self.account_name = account_name self.balance = initial_balance # For instance methods, omit type for \"self\" def deposit(self, amount: int) -\u003e None: self.balance += amount def withdraw(self, amount: int) -\u003e None: self.balance -= amount # User-defined classes are valid as types in annotations account: BankAccount = BankAccount(\"Alice\", 400) def transfer(src: BankAccount, dst: BankAccount, amount: int) -\u003e None: src.withdraw(amount) dst.deposit(amount) ","date":"2024-04-20","objectID":"/20240421_type-hint/:0:6","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":["Python"],"content":"Annotated Annotated in python allows developers to declare type of a reference and and also to provide additional information related to it. name = Annotated[str, \"first letter is capital\"] This tells that name is of type str and that name[0] is a capital letter. On its own Annotated does not do anything other than assigning extra information (metadata) to a reference. It is up to another code, which can be a library, framework or your own code, to interpret the metadata and make use of it. For example FastAPI uses Annotated for data validation: def read_items(q: Annotated[str, Query(max_length=50)]) Here the parameter q is of type str with a maximum length of 50. This information was communicated to FastAPI (or any other underlying library) using the Annotated keyword. Annotated[\u003ctype\u003e, \u003cmetadata\u003e] Here is an example of how you might use Annotated to add metadata to type annotations if you were doing range analysis: @dataclass class ValueRange: lo: int hi: int T1 = Annotated[int, ValueRange(-10, 5)] T2 = Annotated[T1, ValueRange(-20, 3)] ","date":"2024-04-20","objectID":"/20240421_type-hint/:0:7","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":["Python"],"content":"TypeVar This is a special type for generic types. from typing import Sequence, TypeVar, Iterable T = TypeVar(\"T\") # `T` is typically used to represent a generic type variable def batch_iter(data: Sequence[T], size: int) -\u003e Iterable[Sequence[T]]: for i in range(0, len(data), size): yield data[i:i + size] Since the generic type is used, batch_iter function can take any type of Sequence type data. For instance, Sequence[int], Sequence[str], Sequence[Person] If we use bound, then we can restrict the generic type. For example, from typing import Sequence, TypeVar, Iterable, Union T = TypeVar(\"T\", bound=Union[int, str, bytes]) def batch_iter(data: Sequence[T], size: int) -\u003e Iterable[Sequence[T]]: for i in range(0, len(data), size): yield data[i:i + size] Thus, the following code will show an error as it takes a list of float numbers: batch_iter([1.1, 1.3, 2.5, 4.2, 5.5], 2) Note that in Python 3.12, generic type hint has been changed ","date":"2024-04-20","objectID":"/20240421_type-hint/:1:0","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":["Python"],"content":"Reference ArjanCodes Type hint cheat sheet ","date":"2024-04-20","objectID":"/20240421_type-hint/:2:0","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":null,"content":"About Han","date":"2024-04-21","objectID":"/about/","tags":null,"title":"About Han","uri":"/about/"},{"categories":null,"content":"Han Cheol Moon I am a curiosity-driven Machine Learning Scientist, passionate about exploring the depths of data and algorithms. As an enthusiastic learner and code lover, I am always eager to expand my knowledge and embrace innovation. ","date":"2024-04-21","objectID":"/about/:0:0","tags":null,"title":"About Han","uri":"/about/"},{"categories":null,"content":"Research Interests Natural language processing (NLP) Robustness of NLP systems ","date":"2024-04-21","objectID":"/about/:1:0","tags":null,"title":"About Han","uri":"/about/"},{"categories":null,"content":"Professional Employments Samsung Electronics Staff ML/DL Engineer, Sept 2023 - Present ","date":"2024-04-21","objectID":"/about/:2:0","tags":null,"title":"About Han","uri":"/about/"},{"categories":null,"content":"Education Nanyang Technological University, 2019-2023 Ph.D. in Computer Science Yonsei University, 2016-2018 M.S. in Electrical \u0026 Electronic Engineering Chung-Ang University, 2009-2016 B.S. in Electrical \u0026 Electronic Engineering (Military Service, 2009-2012) ","date":"2024-04-21","objectID":"/about/:3:0","tags":null,"title":"About Han","uri":"/about/"},{"categories":null,"content":"Skills Programming Languages Python, C/C++, MATLAB, and Bash/Shell ML/DL Research PyTorch, Tensorflow, Scipy, Numpy, Scikit-learn, Pandas, and HuggingFace ML/DL Ops Git, Docker, Kubernetes, Jenkins, DVC, FastAPI, and LangChain Database SQLite and PostgreSQL with SQLAlchemy and Alembic WebDev HTML/CSS, Django, and Hugo WorkFlow I’ve used Microsoft and GNU/Linux systems (both Debian and Arch-based varieties) with a Vim-based setup for writing scripts and managing files in a tiling window manager (i3). I use Git for version control with Docker and schedule multiple tasks with TaskSpooler. I compile documents using $\\LaTeX$. Soft Skills Time Management, Teamwork, Problem-solving, Documentation, Engaging Presentation. ","date":"2024-04-21","objectID":"/about/:4:0","tags":null,"title":"About Han","uri":"/about/"},{"categories":null,"content":"Teaching ","date":"2024-04-21","objectID":"/about/:5:0","tags":null,"title":"About Han","uri":"/about/"},{"categories":null,"content":"Teaching Assistant DeepNLP, 2019-2020 Nanyang Technological University, Singapore Digital Logic Circuits, Spring 2018 Yonsei University, Korea Multimedia Signal Processing, Fall 2017 Yonsei University, Korea Signals and Systems, Fall 2016 Yonsei University, Korea ","date":"2024-04-21","objectID":"/about/:5:1","tags":null,"title":"About Han","uri":"/about/"},{"categories":null,"content":"Honors and Award Singapore International Graduate Award (SINGA), 2019-2023 Top of Class Scholarship, Chung-Ang University, 2015 Dean’s List, Chung-Ang University, 2013-2014 ","date":"2024-04-21","objectID":"/about/:6:0","tags":null,"title":"About Han","uri":"/about/"},{"categories":null,"content":"Service and leadership Military Service, 2009-2012 Republic of Korea Army, Capital Defense Command ‘SHIELD’, 1st Security Group Guarding presidential residence Sergeant ","date":"2024-04-21","objectID":"/about/:7:0","tags":null,"title":"About Han","uri":"/about/"}]