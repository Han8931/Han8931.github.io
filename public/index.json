[{"categories":["Linux"],"content":"You should use Linux!","date":"2024-04-21","objectID":"/20240421_why-linux/","tags":["Linux","Minimalism"],"title":"Minimalism Through Linux","uri":"/20240421_why-linux/"},{"categories":["Linux"],"content":"Embracing Minimalism Through Linux: A Path to Digital Simplicity In an age dominated by digital clutter and overwhelming software choices, the minimalist philosophy stands out as a beacon for those seeking simplicity and efficiency. This approach not only applies to physical possessions but extends into the digital realm, where Linux has become a preferred tool for minimalists. Linux, an open-source operating system, embodies the principles of minimalism by offering users control over their digital environments. Unlike mainstream operating systems that often come loaded with non-essential features and bloatware, Linux allows users to select only the components they need, creating a lean and efficient system. The minimalist appeal of Linux is evident in its customizable nature. Users can choose from a variety of distributions, each tailored for different needs. For instance, distributions like Arch Linux provide a barebones setup that users can expand as needed. This customization extends to the user interface, where options range from feature-rich desktop environments to more austere ones like i3wm or DWM, which use fewer resources and maintain a clean, unobtrusive design. Furthermore, Linux’s robust command-line interface is a minimalist’s dream. It enables users to perform tasks efficiently without the graphical overhead, which is particularly appealing to those who favor functionality and speed over visual elements. The simplicity of Linux does not stop at its interface; it is also reflected in its performance. Linux distributions are well-known for their speed and stability, even on older hardware. This capability to revive older machines and keep them running efficiently aligns with the minimalist ethos of reducing waste and maximizing utility. Moreover, Linux champions the concept of free software, which resonates with minimalists’ preference for authenticity and freedom from commercial constraints. Users are free to modify, improve, and redistribute their software in ways that proprietary systems do not allow. Linux offers a compelling choice for anyone looking to embrace a minimalist digital lifestyle. It provides the tools to create a personalized and uncluttered digital environment, encourages the efficient use of resources, and upholds values of freedom and simplicity. For those seeking to reduce their digital footprint while maximizing functionality, Linux proves that less can indeed be more. ","date":"2024-04-21","objectID":"/20240421_why-linux/:0:1","tags":["Linux","Minimalism"],"title":"Minimalism Through Linux","uri":"/20240421_why-linux/"},{"categories":["Python"],"content":"Guide to keep sensitive data in Python","date":"2024-04-20","objectID":"/20240421_hide-sensitive-data/","tags":["Python","dotenv"],"title":"How to keep sensitive data in Python?","uri":"/20240421_hide-sensitive-data/"},{"categories":["Python"],"content":"How to keep config file? An app’s config is everything that is likely to vary between deploys (staging, production, developer environments, etc). This includes: Resource handles to the database, Memcached, and other backing services Credentials to external services such as Amazon S3 or Twitter Per-deploy values such as the canonical hostname for the deploy Apps sometimes store config as constants in the code. This is a violation of twelve-factor, which requires strict separation of config from code. Config varies substantially across deploys, code does not. A litmus test for whether an app has all config correctly factored out of the code is whether the codebase could be made open source at any moment, without compromising any credentials. The twelve-factor app stores config in environment variables (often shortened to env vars or env). Env vars are easy to change between deploys without changing any code; unlike config files, there is little chance of them being checked into the code repo accidentally; and unlike custom config files, or other config mechanisms such as Java System Properties, they are a language- and OS-agnostic standard. In a twelve-factor app, env vars are granular controls, each fully orthogonal to other env vars. They are never grouped together as “environments”, but instead are independently managed for each deploy. This is a model that scales up smoothly as the app naturally expands into more deploys over its lifetime. ","date":"2024-04-20","objectID":"/20240421_hide-sensitive-data/:0:0","tags":["Python","dotenv"],"title":"How to keep sensitive data in Python?","uri":"/20240421_hide-sensitive-data/"},{"categories":["Python"],"content":"Environment Variable For example, you shouldn’t put information directly in your code. db_user = 'my_db_user' db_password = 'my_db_pass_123!' Let’s keep the sensitive information in .bash_profile as follows: export DB_USER=\"my_db_user\" export DB_PASS='my_db_pass_123!' Then, we can call them by import os db_user = os.environ.get('DB_USER') db_password = os.environ.get('DB_PASS') ","date":"2024-04-20","objectID":"/20240421_hide-sensitive-data/:1:0","tags":["Python","dotenv"],"title":"How to keep sensitive data in Python?","uri":"/20240421_hide-sensitive-data/"},{"categories":["Python"],"content":"dotenv ","date":"2024-04-20","objectID":"/20240421_hide-sensitive-data/:2:0","tags":["Python","dotenv"],"title":"How to keep sensitive data in Python?","uri":"/20240421_hide-sensitive-data/"},{"categories":["Python"],"content":"Introduction Python-dotenv reads key-value pairs from a .env file and can set them as environment variables. It helps in the development of applications following the 12-factor principles. ","date":"2024-04-20","objectID":"/20240421_hide-sensitive-data/:2:1","tags":["Python","dotenv"],"title":"How to keep sensitive data in Python?","uri":"/20240421_hide-sensitive-data/"},{"categories":["Python"],"content":"Basics Installation: pip install python-dotenv Create .env file in your project directory. Put the data (or variables) in the .env file. e.g, API_KEY=\"dafjei304aldkjf20akj\" To load your key, First, use load_dotenv() with os.getenv(\"[Your variable]\") e.g., API_KEY=os.getenv(\"API_KEY\") Make sure to update .gitignore to exclude the .env file. from dotenv import load_dotenv load_dotenv() API_KEY = os.getenv(\"API_KEY\") or \"\" ","date":"2024-04-20","objectID":"/20240421_hide-sensitive-data/:2:2","tags":["Python","dotenv"],"title":"How to keep sensitive data in Python?","uri":"/20240421_hide-sensitive-data/"},{"categories":["Python"],"content":"Guide to understand type hint in Python.","date":"2024-04-20","objectID":"/20240421_type-hint/","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":["Python"],"content":"Reference: Link ArajanCode Type hinting is not mandatory, but it can make your code easier to understand and debug. Improved readability Better IDE support: IDEs and linters can use type hints to check your code for potential errors before runtime. While type hints can be simple classes like float or str , they can also be more complex. The typing module provides a vocabulary of more advanced type hints. Type hint cheat sheet ","date":"2024-04-20","objectID":"/20240421_type-hint/:0:0","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":["Python"],"content":"Basics # This is how you declare the type of a variable age: int = 1 # You don't need to initialize a variable to annotate it a: int # Ok (no value at runtime until assigned) # Doing so can be useful in conditional branches child: bool if age \u003c 18: child = True else: child = False x: int = 1 x: float = 1.0 x: bool = True x: str = \"test\" x: bytes = b\"test\" # For collections on Python 3.9+, the type of the collection item is in brackets x: list[int] = [1] x: set[int] = {6, 7} # For mappings, we need the types of both keys and values x: dict[str, float] = {\"field\": 2.0} # Python 3.9+ # For tuples of fixed size, we specify the types of all the elements x: tuple[int, str, float] = (3, \"yes\", 7.5) # Python 3.9+ # For tuples of variable size, we use one type and ellipsis x: tuple[int, ...] = (1, 2, 3) # Python 3.9+ # On Python 3.8 and earlier, the name of the collection type is # capitalized, and the type is imported from the 'typing' module from typing import List, Set, Dict, Tuple x: List[int] = [1] x: Set[int] = {6, 7} x: Dict[str, float] = {\"field\": 2.0} x: Tuple[int, str, float] = (3, \"yes\", 7.5) x: Tuple[int, ...] = (1, 2, 3) ","date":"2024-04-20","objectID":"/20240421_type-hint/:0:1","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":["Python"],"content":"Union Union is for multiple types def process_message(msg: Union[str, bytes, None]) -\u003e str: ... # On Python 3.10+, use the | operator when something could be one of a few types x: list[int | str] = [3, 5, \"test\", \"fun\"] # Python 3.10+ # On earlier versions, use Union x: list[Union[int, str]] = [3, 5, \"test\", \"fun\"] ","date":"2024-04-20","objectID":"/20240421_type-hint/:0:2","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":["Python"],"content":"Optional # food can be either str or None. def eat_food(food: Optional[str]) -\u003e None: ... # Use Optional[X] for a value that could be None # Optional[X] is the same as X | None or Union[X, None] x: Optional[str] = \"something\" if some_condition() else None if x is not None: # Mypy understands x won't be None here because of the if-statement print(x.upper()) # If you know a value can never be None due to some logic that mypy doesn't # understand, use an assert assert x is not None print(x.upper()) ","date":"2024-04-20","objectID":"/20240421_type-hint/:0:3","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":["Python"],"content":"Any Any is a special type hint in Python that indicates that a variable can be of any type. It essentially disables static type checking for that variable. It’s typically used when you want to explicitly indicate that a certain variable can have any type, or when dealing with dynamically typed code where the type of the variable cannot be easily inferred. While Any provides flexibility, it also sacrifices the benefits of static type checking, as type errors related to variables annotated as Any won’t be caught by type checkers. ","date":"2024-04-20","objectID":"/20240421_type-hint/:0:4","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":["Python"],"content":"Functions: Callable Types Callable type hint can define types for callable functions. from typing import Callable Callable[[Parameter types, ...], return_types] Callable objects are functions, classes, and so on. Type [input types] and return types def on_some_event_happened(callback: Callable[[int, str, str], int]) -\u003e None: ... def do_this(a: int, b: str, c:str) -\u003e int: ... on_some_event_happened(do_this) # This is how you annotate a callable (function) value x: Callable[[int, float], float] = f def register(callback: Callable[[str], int]) -\u003e None: ... # A generator function that yields ints is secretly just a function that # returns an iterator of ints, so that's how we annotate it def gen(n: int) -\u003e Iterator[int]: i = 0 while i \u003c n: yield i i += 1 # You can of course split a function annotation over multiple lines def send_email(address: Union[str, list[str]], sender: str, cc: Optional[list[str]], bcc: Optional[list[str]], subject: str = '', body: Optional[list[str]] = None ) -\u003e bool: ... ","date":"2024-04-20","objectID":"/20240421_type-hint/:0:5","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":["Python"],"content":"Classes class BankAccount: # The \"__init__\" method doesn't return anything, so it gets return # type \"None\" just like any other method that doesn't return anything def __init__(self, account_name: str, initial_balance: int = 0) -\u003e None: # mypy will infer the correct types for these instance variables # based on the types of the parameters. self.account_name = account_name self.balance = initial_balance # For instance methods, omit type for \"self\" def deposit(self, amount: int) -\u003e None: self.balance += amount def withdraw(self, amount: int) -\u003e None: self.balance -= amount # User-defined classes are valid as types in annotations account: BankAccount = BankAccount(\"Alice\", 400) def transfer(src: BankAccount, dst: BankAccount, amount: int) -\u003e None: src.withdraw(amount) dst.deposit(amount) ","date":"2024-04-20","objectID":"/20240421_type-hint/:0:6","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":["Python"],"content":"Annotated Annotated in python allows developers to declare type of a reference and and also to provide additional information related to it. name = Annotated[str, \"first letter is capital\"] This tells that name is of type str and that name[0] is a capital letter. On its own Annotated does not do anything other than assigning extra information (metadata) to a reference. It is up to another code, which can be a library, framework or your own code, to interpret the metadata and make use of it. For example FastAPI uses Annotated for data validation: def read_items(q: Annotated[str, Query(max_length=50)]) Here the parameter q is of type str with a maximum length of 50. This information was communicated to FastAPI (or any other underlying library) using the Annotated keyword. Annotated[\u003ctype\u003e, \u003cmetadata\u003e] Here is an example of how you might use Annotated to add metadata to type annotations if you were doing range analysis: @dataclass class ValueRange: lo: int hi: int T1 = Annotated[int, ValueRange(-10, 5)] T2 = Annotated[T1, ValueRange(-20, 3)] ","date":"2024-04-20","objectID":"/20240421_type-hint/:0:7","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":["Python"],"content":"TypeVar This is a special type for generic types. from typing import Sequence, TypeVar, Iterable T = TypeVar(\"T\") # `T` is typically used to represent a generic type variable def batch_iter(data: Sequence[T], size: int) -\u003e Iterable[Sequence[T]]: for i in range(0, len(data), size): yield data[i:i + size] Since the generic type is used, batch_iter function can take any type of Sequence type data. For instance, Sequence[int], Sequence[str], Sequence[Person] If we use bound, then we can restrict the generic type. For example, from typing import Sequence, TypeVar, Iterable, Union T = TypeVar(\"T\", bound=Union[int, str, bytes]) def batch_iter(data: Sequence[T], size: int) -\u003e Iterable[Sequence[T]]: for i in range(0, len(data), size): yield data[i:i + size] Thus, the following code will show an error as it takes a list of float numbers: batch_iter([1.1, 1.3, 2.5, 4.2, 5.5], 2) Note that in Python 3.12, generic type hint has been changed ","date":"2024-04-20","objectID":"/20240421_type-hint/:1:0","tags":["Python","type hint"],"title":"Type hint in Python","uri":"/20240421_type-hint/"},{"categories":null,"content":"About Han","date":"2024-04-21","objectID":"/about/","tags":null,"title":"About Han","uri":"/about/"},{"categories":null,"content":"Han Cheol Moon ","date":"2024-04-21","objectID":"/about/:0:0","tags":null,"title":"About Han","uri":"/about/"},{"categories":null,"content":"Research Interests Natural language processing (NLP) Robustness of NLP systems ","date":"2024-04-21","objectID":"/about/:1:0","tags":null,"title":"About Han","uri":"/about/"},{"categories":null,"content":"Education Nanyang Technological University, 2019-2023 Ph.D. in Computer Science Yonsei University, 2016-2018 M.S. in Electrical \u0026 Electronic Engineering Chung-Ang University, 2009-2016 B.S. in Electrical \u0026 Electronic Engineering (Military Service, 2009-2012) ","date":"2024-04-21","objectID":"/about/:2:0","tags":null,"title":"About Han","uri":"/about/"},{"categories":null,"content":"Skills Programming Languages Python, C/C++, MATLAB, and Bash/Shell ML/DL Research PyTorch, Tensorflow, Scipy, Numpy, Scikit-learn, Hugging Face, and Pandas ML/DL Ops Git, Docker, Kubernetes, Jenkins, FastAPI, and LangChain Linux/Unix (Debian and Arch-based distros) Database SQLite and PostgreSQL with SQLAlchemy and Alembic WorkFlow I’ve used Microsoft and GNU/Linux systems (both Debian and Arch-based varieties) with a Vim-based setup for writing scripts and managing files in a tiling window manager (i3). I use Git for version control with Docker and schedule multiple tasks with TaskSpooler. I compile documents using $\\LaTeX$. Soft Skills Time Management, Teamwork, Problem-solving, Documentation, Engaging Presentation. Miscellaneous Vim, i3wm, Git, LaTex and Inkscape ","date":"2024-04-21","objectID":"/about/:3:0","tags":null,"title":"About Han","uri":"/about/"},{"categories":null,"content":"Teaching ","date":"2024-04-21","objectID":"/about/:4:0","tags":null,"title":"About Han","uri":"/about/"},{"categories":null,"content":"Teaching Assistant DeepNLP, 2019-2020 Nanyang Technological University, Singapore Digital Logic Circuits, Spring 2018 Yonsei University, Korea Multimedia Signal Processing, Fall 2017 Yonsei University, Korea Signals and Systems, Fall 2016 Yonsei University, Korea ","date":"2024-04-21","objectID":"/about/:4:1","tags":null,"title":"About Han","uri":"/about/"},{"categories":null,"content":"Honors and Award Singapore International Graduate Award (SINGA), 2019-2023 Top of Class Scholarship, Chung-Ang University, 2015 Dean’s List, Chung-Ang University, 2013-2014 ","date":"2024-04-21","objectID":"/about/:5:0","tags":null,"title":"About Han","uri":"/about/"},{"categories":null,"content":"Service and leadership Military Service, 2009-2012 Republic of Korea Army, Capital Defense Command ‘SHIELD’, 1st Security Group Guarding presidential residence Sergeant ","date":"2024-04-21","objectID":"/about/:6:0","tags":null,"title":"About Han","uri":"/about/"}]